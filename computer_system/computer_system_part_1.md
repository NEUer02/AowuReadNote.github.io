<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 深入理解计算机系统

参考书目：《深入理解计算机系统》 兰德尔 E. 布莱恩特

本页内容来自于个人学习笔记与感悟。 
仅限于学习交流，请勿商用。

## 第一章 计算机系统漫游

### 1-1 信息就是 位+上下文

本书从编译一段最经典的C语言程序讲起。

```c
#include<stdio.h>


int main()
{
    printf("hello, world!");
    return 0;
}
```

我们编写好的C语言程序以后缀为“.c”文本的形式存在，称之为源文件。之后通过GCC等编译器驱动程序，例如：

```shell
gcc -o hello hello.c
```

将C语句转化为低级的机器语言，生成可执行文件hello。

GCC在编译源文件时需要经过四个步骤：预处理器(cpp)，编译器(ccl)、汇编器(as)与连接器(Id)。

1. 预处理器：预处理器将源文件中以“#”开头的命令为依据，修改源文件。例如：“#include<stdio.h>”就会将“stdio.h”这个文件插入到这里。处理完的文件后缀变为“.i”;

2. 编译器：将“hello.i”文件中的命令翻译为汇编语言，后缀改为“.s”；

3. 汇编器：将编译器翻译出的汇编语言转换为更低级的机器语言指令，将这些指令打包为“可重定位目标程序”的格式。也就是编译中常常出现的后缀为“.o”的文件。此时这个文件已不是文本，而是二进制文件；

4. 连接器：将C文件中调用的对应的预编译文件（.o文件）与C文件编译出的预编译文件以某种方式聚合在一起。例如，hello.c程序中调用的stdio.h中的printf函数，此时就需要将hello.o与printf.o聚合在一起，生成hello，这样就生成了一个可执行文件。

### 1-2 hello程序在硬件上运行

1. 当我们在shell命令行中输入：
   
   ```shell
   ./hello
   ```
   
   时，shell程序将字符逐一读入寄存器，再他们逐个放入内存中；

2. 当我们输入回车时，shell程序知道我们完成了输入，之后开始加载可执行文件hello，这个过程通过一系列指令将可执行文件中的代码和数据从磁盘中复制到内存中；（直接存储器存取技术可以直接将数据从磁盘复制到内存中而不用通过处理器）

3. 当代码和数据加载到内存中后，处理器开始执行程序中的main函数，运行到输出“hello, world!”时，该指令从内存中将字符串复制到寄存器，再从寄存器复制到显示设备。

上述过程中，不知道各位发现了什么问题没有，就是：系统需要频繁地将数据从一个地方复制到另一个地方，而真正执行的动作就被延后了。这不仅需要合理的程序设计，也需要更快速的存储读写速度和查找速度。

根据机械原理，存储量越大运行越慢，运行越快造价越贵。而且随着半导体技术的进步，处理器与主存之间的速度差距越来越大。这时就出现了CPU的高速缓存，即通常在CPU广告页中见到的一级缓存/二级缓存/三级缓存（AMD 5800X3D 三缓已来到96MB，AMD 线程撕裂者 5995WX 三缓来到 256MB）。这些高速缓存是静态随机存储器（SRAM），将可能经常访问的程序与数据放在高速缓存中可以有效地提升程序性能。

既然我们现在知道了这么多存储器的类型，那它们之间的结构又是怎样的呢？

![](..\data\picture\computer_system\存储结构.jpg)

这种结构的主要思想就是：上一层存储器作为低一层存储器的高速缓存。即L1作为L2的高速缓存，L2作为L3的高速缓存......

### 1-3 操作系统

操作系统本质上就是应用程序与底层硬件之间插入的一层程序。

其作用主要是两点：

1. 防止硬件被失控的应用程序滥用；

2. 向应用程序提供简单一致的机制来控制硬件设备；

要做到以上两点，操作系统使用了三种方式：进程、虚拟内存、文件。

（插一句：为了让用户看似在独占的使用一台电脑，这时候对操作系统进行抽象，称为虚拟机）

#### 1-3-1 进程

进程是对处理器、主存和I/O设备的抽象表示。进程是操作系统对于一个正在运行的应用程序的一种抽象。目的是让每个进程看似再独占地使用硬件。

并发执行是通过在进程之间的切换做到的。这种机制称为：上下文切换。

单处理器在任何时刻都只能处理一个进程。当处理器要从当前进程切换到另一进程时，需要保存当前进程的状态信息，这些内容称之为上下文。保存好之后，系统切换到新进程的上下文，控制权转移至新进程，这时新进程就会从上次停止的地方开始。

上下文切换是由操作系统的内核来管理的。当应用程序需要操作系统完成某些动作时（如shell程序调用hello程序），它会执行一个特殊的系统调用，系统会将控制权转移给内核，内核完成相应的动作。

以运行hello程序为例，在shell命令行输入时，此时只有shell命令行一个进程，在收到hello程序的调用请求后，shell通过一个系统调用，系统将控制权从shell程序转移至系统内核，内核在保存好shell程序的上下文之后，建立新的hello程序的上下文，并将控制权转交给hello程序。hello程序运行结束后，内核恢复shell程序的上下文，并将控制权转移回shell程序。

#### 1-3-2 线程

一个进程之内有多个执行单元组成，该执行单元称之为线程。线程之间共享着同样的代码和全局数据，线程相较于进程之间也更用以交换数据。

#### 1-3-3 虚拟内存

虚拟内存使进程开起来是在独享主存一样。每个进程看到的内存都是一致的，称之为虚拟地址空间。

![](..\data\picture\computer_system\进程的虚拟地址空间.jpg)

堆和栈的区别：

- 栈区(stack):由编译器自动分配和释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆区(heap):一般由程序员分配和释放，若程序员不释放，程序结束时可能由操作系统回收。它与数据机构中的堆是两回事，分配方式类似于链表

#### 1-3-4 文件

将每一个I/O设备都看成是未见。设备的输入输出都是通过系统函数调用读写文件来实现的。“文件”这个概念向应用程序提供了一个统一的视图，而无需让应用程序直接面对庞杂的底层硬件。

### 1-4 Amdahl定律

当我们对系统的某个部分加速时，其对整体性能的影响取决于该部分的重要性和加速程度。若系统执行某个应用程序所需的时间为$T_{old}$，某部分执行时间与总体执行实际时间之比为$\alpha$，而该部分性能提升比例为$K$,则：

$$
T_{new}=(1-\alpha) \times T_{old} + \alpha \times T_{old} / K
= T_{old} \times [(1- \alpha) + \frac{\alpha}{K}]
$$

则加速比$S$为：

$$
S = \frac{T_{old}}{T_{new}} = \frac{1}{(1- \alpha) + \frac{\alpha}{K} }
$$

由该定律可知：想要显著加速整个系统，必须提升全系统中相当大的部分的速度。

当$K \rightarrow \infty$时，即将系统的某一部分无限加速，最终的加速比$S$为：

$$
S = \lim_{K\rightarrow+\infty} \frac{T_{old}}{T_{new}} = \frac{1}{1 - \alpha}
$$

此时加速比仅取决于该部分在系统中的占比，这也从侧面验证了Amdahl定律。

### 1-5 并发与并行

这两个概念从英文上区别起来比较容易。并发的英文是concurrency，并行为parallelism。

并发从英文的角度解释为“共同的”“流”，即指一个同时具有多个活动的系统；

并行从英文的角度解释为“平行主义”，即用并发使一个系统运行的更快；

并发在系统层次结构中从高到低分为：线程级并发、指令集并行与单指令，多数据并行；

#### 1-5-1 线程级并发

当一个内核控制多个处理器时，就意味着该系统为一个多处理器系统。将多个CPU集成在一起，每个都有自己的L1与L2缓存，大家共享L3缓存。同时还有超线程技术，又称为同时多线程技术，是一项允许CPU执行多个控制流的技术。

线程级并发作用是：

1. 可以同时处理多个任务；

2. 多线程使得上下文切换的很快；

其效果为：

1. 减少了执行多个任务时模拟并发的需要；

2. 加快了程序的运行（当然程序是按照多线程写的）；

#### 1-5-2 指令集并行

现代处理器可以同时执行多条指令的属性称为指令集并行。如果处理器可以达到一个周期一条指令更快的执行速度，称其为超标量处理器。

#### 1-5-3 单指令，多数据并行

现代处理器由于使用了特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令，多数据，即SIMD并行。SIMD多是用于提高对处理影像，声音和视频数据应用的执行速度。例如：并行地对8对单浮点数做加法指令。

用编译器支持的特殊向量数据类型来编写程序也可以提高运行速度。
